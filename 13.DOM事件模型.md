### DOM事件的基础知识
> 事件是元素天生自带的默认行为
  - 不论我们是否给其绑定了方法，当我们操作的时候，也会把对应的事件触发。
> 事件绑定是给元素的某个行为绑定一个方法
 - 目的是当事件行为触发的时候，可以做一些事情

> 常用的事件行为
  - [鼠标事件]
    + click 点击（移动端click被识别位单击）
    + dbclick 双击
    + mousedown 鼠标按下
    + mouseup 鼠标抬起
    + mouseover 鼠标滑过
    + mousemove 鼠标移动
    + mouseout 鼠标滑出
    + mouseenter 鼠标进入
    + mouseleave 鼠标离开
    + whell 鼠标滚轮滚动
    + contextmenu 鼠标右键触发
  - [键盘事件]
    + keydown 按下某个键
    + keyup 抬起某个键
    + keypress 除shift、fn、capslock键以外，其它键按住（连续触发）
      code & key:存储的都是按键，code更细致
      keycode & which：存储的是键盘按键对应的码值
        方向键：37 38 39 40 左上右下
        空格SPACE 32
        回车ENTER 13
        回退BACK 8
        删除DEL 46
        SHIFT 16
        CTRL 17
        ALT 18
        ...
  - [移动端手指事件]
    `单手指事件模型 Touch`
      + touchstart 手指按下
      + touchmove 手指移动
      + touchend 手指松开
      + touchcancel 操作取消（一般应用于非正常状态下的操作结束） 
    `多手指模型`
      + gesturestart
      + gesturechange / gestureupdate
      + gestureend
      + gesturecancel 
  - [表单事件]
    + focus 获取焦点
    + blur 失去焦点
    + change 内容改变
    + input 元素获取用户输入时触发
    + reset 表单重置时触发
    + submit 表单提交时触发
  - [音视频事件]
    + canplay 可以播放（资源没有加载完，播放中可能出现卡顿）
    + canplaythrough 可以播放 （资源已经加载完了，播放中不会卡顿）
    + play 开始播放音频时触发
    + playing 暂停或者在缓冲后准备重新播放时触发
    + pause 音频暂停时触发
  - [其他事件]
    + load 资源加载完触发
    + unload 资源卸载被触发
    + beforeunload 即将离开页面（刷新或关闭）页面时触发
    + error 资源加载失败
    + scroll 滚动事件
    + readystatechange AJAX请求状态改变事件
    + resize 窗口被改变时触发
    + contextmenu 鼠标右键触发
  - [拖动事件]
    + drag	该事件在元素正在拖动时触发	 
    + dragenter	该事件在拖动的元素进入放置目标时触发	 
    + dragleave	该事件在拖动元素离开放置目标时触发	 
    + dragover	该事件在拖动元素在放置目标上时触发	 
    + dragstart	该事件在用户开始拖动元素时触发	 
    + dragend	该事件在用户完成元素的拖动时触发	 
    + drop	该事件在拖动元素放置在目标区域时触发

#### DOM0事件绑定和DOM2事件绑定
> [DOM0] 元素.on事件行为 = function(){}
  - 原理：给元素的私有属性赋值，当事件触发，浏览器会帮我们把赋的值执行，但是这样会导致“只能能给当前元素同一个事件行为绑定一个方法”
  - 移除事件绑定：DOM0直接赋值null即可 元素.on事件行为 = null
> [DOM2] 元素.addEventListener(事件行为,function(){},true/false)
  IE6-8: 元素.attachEvent(on+事件行为,function(){})
  - 原理：基于原型链查找机制，找到EventTarget.prototype上的方法并且执行，此方法执行，会把给当前元素某个事件行为绑定的所有方法，存放到浏览器默认的事件池中（绑定几个方法，会向事件池存储几个），等到事件行为触发，会把事件池中的对应方法，依次按照顺序执行 “给当前元素某一个事件行为绑定多个不同的方法”
  - DOM2事件绑定的时候，我们一般都采用实名函数，目的：这样可以基于实名函数移除事件绑定。
  - 移除事件绑定：从事件池中移除，需要指定好事件类型、方法等信息（要和绑定的时候一样才可以移除） removeEventListener(事件行为,绑定的实名函数)
  - 向事件池中增加方法，存在去重机制，同一个元素、事件类型在事件池中只能存储一遍同一个方法，不能重复存储
> DOM0中能做事件绑定的时间行为，DOM2都支持，DOM2里面的一些事件，DOM0不一定能处理绑定，例如，transitionend、DOMContentLoaded、contextmenu
> JQ中的事件绑定采用的都是DOM2事件绑定，例如on/off/one


#### 事件对象和事件传播机制

**事件对象**
> 给元素的事件绑定方法，当事件行为触发会被执行，不仅被执行，而且还会把当前操作的相关信息传递给这个函数=>"事件对象"
> 如果时鼠标操作，获取的时MouseEvent类的实例 =>鼠标事件对象
  - 鼠标事件对象 -> MouseEvent.prototype -> UIEvent.prototype ->Event.prototype ->Object.prototype
    + clientX/clientY：当前鼠标触发点，距离当前窗口左上角的X/Y轴坐标
    + pageX/pageY：出发带你距离当前页面左上角的X/Y轴坐标
    + type：触发事件的类型
    + target：事件源（操作事件的元素对象），在不兼容的浏览器中可以使用srcElement获取
    + preventDefault()：用来阻止默认行为的方法，不兼容的浏览器使用ev.returnValue=false 也可以阻止默认行为
    + stopPropagation()：用来阻止冒泡传播，不兼容的浏览器使用ev.cancelBubble = true 也可以阻止冒泡传播
> 如果时键盘操作，获取的时KeyboardEvent类的实例 =>键盘事件对象
> 除了以上还有：普通事件对象(Event)、手指事件对象(TouchEvent)等
> 事件对象和函数以及给谁绑定的事件没啥必然关系，它存储的时当前本次操作的相关信息，操作一次只能有一份信息，所以在那个方法中获取的信息都是一样的；第二次操作，存储的信息会把上一次操作存储的信息替换掉。
  - 每一次事件触发，浏览器都会这样处理一下:
    + 1.捕获到当前操作的行为（把操作信息获取到），通过创建MouseEvent等类的实例，得到事件对象ev。
    + 2.通知所有绑定的方法（符合执行条件的）开始执行，并且把EV当作实参传递给每个方法，所以在每个方法中的到的事件对象其实是一个
    + 3.后面在重新触发这个事件行为，或重新获取本次操作的信息，用新的信息替换老的信息，然后继续之前的步骤。