## number数字类型
> 包含：常规数字、NaN

### NaN
> not a number:不是一个数，但它隶属于数字类型
NaN和任何值（包括自己）都不相等：NaN!=NaN,所以我们不能用相等的方式判断是否为非有效数字

### isNaN 
> 检测一个值是否为非有效数字，如果不是有效数字返回TRUE，反之是有效数字返回FALSE

在使用isNaN进行检测的时候，首先会验证检测的值是否为数字类型，如果不是，先基于Number()这个方法，把值转换为数字类型，然后再检测

### 把其他类型值转换为数字类型
- Number([val]):把字符串转换为数字，只要字符串中包含任意一个非有效数字字符（第一个小数点除外）结果都是NaN，空字符串会变成数字0    null -> 0 undefined ->NaN  把引用数据类型转换为数字，是先把他基于toString方法转换 {}/正则/函数 ->NaN  [] -> '' -> 0  
- parseInt/parseFloat([val],[进制])：转换为数字的方法，对于字符串来说它是从左到右依次查找有效数字的字符，(先把值转换为字符串)直到遇到非有效数字字符，停止查找（不管后面是否还有数字，都不再找了），把找到的当作数字返回
- ==进行比较的时候 ，可能要先把其他类型转换为数字再进行比较

### Number原型上的方法 toFixed
num.toFixed(2)  把数字保留两位小数

## string 字符串数据类型
> 所有用单引号、双引号、反引号（ES6模板字符串）包起来的都是字符串

### 把其他类型值转换为字符串
- [val].toString()
- 字符串拼接
  + JS中的加减乘除本应是进行数学运算（如果遇到的值不是数字类型，也需要基于Number()方法把其转换为数字，再进行运算）；但是JS中加法有特殊情况：相加过程中遇到字符串直接变为字符串拼接

## boolean布尔数据类型
> 只有两个值 true/false

### 把其它类型值转换为布尔类型
> 只有0、NaN、''、null、undefined 五个值转换为FALSE，其余都转换为TRUE（而且没有任何的特殊情况）

- Boolean([val])
- !/!!  !取反(先转换为布尔，然后取反);  !! 取反再取反，只相当于转换为布尔 <=> Boolean
- 条件判断:如果条件只是一个值，不是==/===/!=/>= 等这些比较，是要把这个值先转换为布尔类型，再验证真假

## null / undefined (空对象指针/未定义)
> null和undefined都代表的是没有
> null:意料之中（一般都是开始不知道的值，我们手动先设置null，后期再给予赋值操作）

```javascript
let num = null; //let num = 0;一般最好用null作为初始的空值，因为零不是空值，它在栈内存中有自己的存储空间（占了位置）
num = 12
```
> undefined:意料之外（不是我能决定的）
```javascript
let num; //=>创建一个变量没有赋值，默认是undefined
num = 12; //后期可以赋值
```
## object对象数据类型 -普通对象
> {[key]:[value],...} 任何一个对象都是由零到多组键值对（属性名：属性值）组成的（并且属性名不能重复）

> 数组是特殊的对象数据类型


### 阿里的面试题
```javascript
let a = {
  n:1
};
let b = a;
a.x = a = {
  n:2
};
console.log(a.x);//undefined
console.log(b);//{n:1,x:{n:2}}
```

### JS中的数据类型检测
- typeof [val]：用来检测数据类型的运算符
  + 1.首先是一个字符串
  + 2.字符串中包含对应的类型
  + 3.typeof null => 'object' 但是null并不是对象
  + 4.基于typeof无法细分出当前值是普通对象还是数组对象等，因为只要是对象数据类型,返回的结果都是"object"
- instanceof：用来检测当前实例是否属于某个类
- constructor：基于构造函数检测数据类型（也是基于类的方式）
- Object.prototype.toString.call():检测数据类型最好的方法

### JS中的操作语句:判断 循环

### 判断
> 条件成立做什么?条件不成立做什么?
- if / else if / else
- 三元运算符
  + 1.如果处理的事情比较多,我们用括号包起来,每一件事情用逗号分隔
  + 2.如果不需要处理事情,可以用null/undefined占位
- switch case
  + 1.每一种CASE情况结束后最好都加上BREAK
  + 2.default 相当于else 以上case都不成立才执行
  + 3.switch case语句比较都是==="绝对相等" 

1. if/else
```
  if(条件){
    条件成立执行
  }else if(条件2){
    条件2成立执行
  }else{
    以上条件都不成立
  }
```
2. == 与 ===
==: 相等(如果左右两边数据值类型不同,默认先转换为相同的类型,然后比较)
'5'==5 => TRUE
===: 绝对相等(如果类型不一样,肯定不相等,不会默认转换数据类型)
'5'===5 =>FALSE

项目中为了保证业务的严谨,推荐使用===

=============
let i = "10";
i=i+1 => '10'+1 => '101'
i+=1 => '101'
i++ => i=11    i++和以上两种不完全一样，它是纯粹的数学运算

---
++i和i++都是数学运算中的累加1，区别是计算的顺序
let i = 1;
5 + (i++) //先算5+i ->6 然后i再加1 （i= 2）

i = 1
5+ (++i)  //7 先i+1 （i=2）再计算5+i =>7

### Js中的循环
> 重复做某些事情就是循环
- for 循环
  + 1.创建循环初始值
  + 2.设置（验证）循环执行的条件
  + 3.条件成立执行循环体中的内容
  + 4.当前循环结束执行步长累计操作 
  + continue：结束当前这轮循环（continue后面的代码不再执行）继续执行下一轮循环
  + break：强制结束整个循环（break后面的代码不再执行），跳出整个循环
- for in 循环
- for of 循环(es6)
- while 循环
  + while([条件]){...}
- do while 循环
  + do{...}
    while([条件])