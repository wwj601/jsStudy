### 变量提升
> 浏览器为了能够让代码自上而下执行首先会开辟一块内存（栈内存）=> 作用域或执行上下文（context） 第一次叫做全局作用域  **把当前作用域中所有带var/function 关键字的进行提前声明和定义 =>变量提升机制**
 - 1、带var的只是提前声明（declare）”var a“只声明没有赋值，默认值是undefined
 - 2、带function的不仅声明，而且还定义了（defined）“a=13“就是赋值，准确来说就是让变量和某个值进行关联
  
**1.带var和不带var的区别**
  ```javascript
    // =>在全局作用域下的区别
    /* 
      不带var的：相当于给全局对象window设置了一个属性a
      window.a = 13
    */
  console.log(a);//a is not defined
  a = 13;
  console.log(a);//=>window.a

  /* 
    栈内存变量存储空间（全局作用域）
      b
    带var的:是在全局作用域下声明了一个变量b（全局变量）,但是在全局下声明的变量也同样相当于给window增加了一个对应的属性（只有全局作用域具备这个特点）
  */
  var b = 4
  console.log(b);//4 =>创建变量b & 给window设置了属性b
  console.log(window.b);//4
  ```

**在当前作用域下（全局、私有、块作用域），如果创建变量使用的是LET/CONST等，一定不饿能在创建代码的前面使用这些变量，否则会报错：ReferenceError:Cannot access 'xxx' beforeinitalization**

##### let/const和var的区别
> 1.let和const不存在变量提升机制
  - 创建变量的六种方式中：var/function有变量提升，而let/const/class/import都不存在这个机制
> 2.var允许重复声明，而let是不允许的
  - 在相同的作用域中（或执行上下文中），如果使用var/function关键词声明变量并且重复声明，是不会有影响的（声明第一次之后，之后的再遇到就不再重复声明了）
  - 但是使用let/const就不行，浏览器会校验当前作用域中是否已经存在这个变量了，如果已经存在了，则再次基于let/const重新声明就会报错
  
  ```javascript
    //=>在浏览器开辟栈内存提供代码自上而下执行之前，不仅有变量提升的操作，还有很多其它的操作=>”词法解析“或者”词法检测“：就是检测当前即将要执行的代码是否会出现"语法错误 SyntaxError"，如果出现错误，代码将不会再执行（第一行都不会执行）

    console.log(1);//这行代码就已经不会再执行了
    let a = 12
    console.log(a)
    let a = 13;//SyntaxError: Identifier 'b' has already been declared 
    console.log(a)
  ```

  ```javascript
  console.log(1);//1
  // 引用错误，报错之前的代码还会照常执行，报错后面的代码不执行
  console.log(a);//ReferenceError: Cannot access 'a' before initialization
  let a = 12


  // 所谓重复是：不管之前通过什么办法，只要当前栈内存中存在了这个变量我们使用let/const等 重复再声明这个变量就是语法错误
  /* 
  var a =12
  let a = 13 //SyntaxError: Identifier 'a' has already been declared 
  console.log(a);
  */
  
  ```
- 3.let能解决typeof检测时出现的暂时性死区问题(LET比VAR更严谨)
```javascript
  console.log(a);//ReferenceError: a is not defined

  console.log(typeof a);//"undefined" 这是浏览器的BUG，本该是报错的，因为没有a。但是没报错 （暂时性死区）

  console.log(typeof a);//ReferenceError: Cannot access 'a' before initialization
  let a; 
```
#### 作用域链查找机制
> 如何根据作用域链机制向上查找作用域
  - 1.从函数创建开始，作用域就已经指定好了
  - 2.当前函数是在哪个作用域下（N）下创建的，那么函数执行形成的作用域（M）的上级作用域就是N，和”函数在哪执行的没关系，只和创建的地方有关系“


#### 关于条件判断的作用域
> 不管条件是否成立都要进行变量提升
> 但是做函数的有特殊性：在老版本浏览器中，确实是不论条件是否成立，函数也是提前声明或者定义的，但是新浏览器中，为了兼容ES6严谨的语法规范，条件中的函数在变量提升阶段只能提前声明，不能提前定义
> 条件成立，进来后的第一件事是给函数赋值，然后再执行代码

#### 闭包作用域
> 1、创建函数
  - 开辟一个堆内存
  - 把函数体中的代码当作字符串存储进去
  - 把堆内存的地址赋值给函数名/变量名
  - **函数在哪个作用域下创建，那么它执行时候所需要查找的上级作用域就是谁**
> 2、函数执行
  - 形成一个全新的私有作用域、执行上下文、私有栈内存（执行一次形成一个，多个之间也不会产生影响）
  - 形参赋值 & 变量提升
  - 代码执行（把所属堆内存中的代码字符串拿出来一行行执行）
  - **遇到一个变量，首先它是否为私有变量（形参和在私有作用域中声明的变量是私有变量），是私有的就操作自己的变量即可，不是私有的则向上级作用域查找...一直找到全局作用域为止=>作用域链查找机制**
  - 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是**闭包的保护机制**
> 3、关于堆栈内存释放问题
  - 函数执行就会形成栈内存（从内存中分配的一块空间），如果内存都不销毁释放，很容易就会导致栈内存溢出（内存爆满，电脑就卡死了），堆栈内存的释放问题是学习JS的核心知识之一
  - 堆内存释放问题
    + 1、创建一个引用类型值就会产生一个堆内存
    + 2、如果当前创建的堆内存不被其他东西所占用了，（浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉），则会释放； 
  - 栈内存释放
    ```javascript
      //=>打开浏览器形成的全局作用域是栈内存
      //=>手动执行函数形成的私有作用域是栈内存
      //=>基于ES6中的let/const形成的块状作用域也是栈内存
      //=> ...
      /* 
        全局栈内存：关掉页面的时候才会销毁
        私有栈内存：
          1.一般情况下，函数只要执行完成，形成的私有栈内存就会销毁掉（排除出现无限递归、出现死循环的模式）
          2.一旦栈内存中的某个东西（一般都是堆地址）被私有作用域以外的事物给占用了，则当前栈内存不能立即被释放销毁（特点：私有作用域中的私有变量等信息也被保留下来了）=> 市面上认为的闭包：函数执行形成不能被释放的私有栈内存，这样的才是闭包
       */

      function fn(){
        //...
      }
      fn();//=>执行形成栈内存，执行完成栈内存销毁

      function x(){
        return function(){
          //...
        }
      }
      let f = x();//=>f占用了x执行形成的栈内存中的一个东西（返回小函数对应的堆），则x执行形成的栈内存不能被释放了
      
    ```
#### 闭包的两个作用
> 从性能角度讲，我们真实项目中应该减少对闭包的使用（因为闭包会产生不释放的栈内存，过多使用容易导致内存溢出或者降低性能）
- 1.保护（私有变量和外界没有必然联系）
- 2.保存（形成不销毁的栈内存，里面的私有变量等信息保存下来了）

1)jQuery(JQ)前端非常经典的类库：提供了大量的方法供开发人员使用
=>为了防止全局变量的污染，（解释：导入JQ后，它里面有大量的方法，如果这些方法不保护起来，用户编写的方法很容易和JQ方法名字相同产生冲突，产生冲突可以理解为全局变量污染）JQ中的方法和变量需要用闭包保护起来
  ```javascript
  //=>原生js
  var xxx = (function(){
    //...自己的代码
    return xxx
  })()

  (function(){
    //...自己的代码
    window.xxx = xxx
  })();

  //=>JQ
  $(function(){
    //... 这样写再在某些角度上也是为了减少全局的变量
  });
  ```
2)基于LET/COST/CLASS等创建变量，会把所在的大括号（除对象的大括号之外）当作一个全新的私有块级作用域
- 函数执行会产生私有的栈内存（作用域/执行上下文）
- LET等也会产生私有的块级作用域（var不会）
```javascript
if(1===1){
  var a = 10;
}
console.log(a);//10 a是全局作用域


if(1===1){
  //let 会有块作用域（现在大括号就是一个私有作用域）
  // a 是私有作用域
  let a = 10;
}
console.log(a);//=>Uncaught ReferenceError:a is not defined
```

#### this
> 函数执行的主体（不是上下文）：谁把它执行的，那么执行主体就是谁
 - 1、给元素的某个事件绑定方法，当事件触发方法执行的时候，方法中的this是当前操作的元素本身
 - 2、当方法执行的时候，我们看方法前面是否有点，没有点this是window或者严格模式下是undefined；有点，点前面是谁this就是谁；
 ```javascript
  function fn(){
    
  }
 ```
 - 3、在构造函数模式执行中，函数体中的THIS是当前类的实例
  ```javascript
  function Fn(){
    this.name = 'wwj' ;//this是Fn这个类的实例 f
  }
  var f = new Fn();
  console.log(f.name);//'wwj'
  ```