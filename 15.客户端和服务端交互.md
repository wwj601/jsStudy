#### 客户端和服务器端
> 客户端：可以向服务器发送请求，并接收返回的内容进行处理
> 服务器端：能够接收客户端请求，并且把相关资源信息返回给客户端的

##### 客户端和服务端的交互处理

`地址栏输入一个url地址，到看到页面显示，中间经历了什么`
> 1.URL地址解析
> 2.DNS域名解析
> 3.和服务器建立TCP连接（三次握手）
> 4.把客户端信息传递给服务器（发送HTTP请求）
> 5.服务器得到并处理请求（HTTP响应内容）
> 6.客户端渲染服务器返回的内容
> 7.和服务器断开TCP连接（四次挥手）

#### URI/URL/URN
- URL(Uniform Resource Locator):统一资源定位符，根据这个地址可以找到对应的资源
- URN（Uniform Resource Name）：统一资源名称，一般国际上通用的（标准的）一些名字（例如：国际统一发版的编号）
- URI（Uniform Resource Identifer）：统一资源标识符，URL和URN是URI的子集。

#### 一个完整的URL所包含的内容
> http:www.baidu.com:80/stu/index.html?from=wx&lx=1#wan

- 协议（http://）：传输协议就是能够把客户端和服务端进行通讯的信息，进行传输的工具（类似于快递的快递小哥）
  + http 超文本传输协议，除了传递文本，还可以传递媒体资源文件（或者流文件）及XML格式数据
  + https 更加安全的http，一般涉及支付的网站都要采用https协议（s:ssl 加密传输）
  + ftp 文件传输协议，一般应用于把本地资源上传到服务器端
  
- 域名（www.baidu.com）:一个让用户方便记忆的名字（不通过域名，直接使用服务器的外网IP也能访问到服务器，但是外网IP很难被记住）
  + 顶级域名 qq.com
  + 一级域名 www.qq.com
  + 二级域名 sports.qq.com
  + 三级域名 kbs.sports.qq.com
- 端口号（:80）：取值范围0~65535，用端口号来区分同一台服务器上的不同项目
  + http默认端口号:80
  + https默认端口号:443
  + ftp默认端口号:21
  + 如果项目采用的就是默认端口号，我们再写地址的时候可以不用加端口号，浏览器再发送请求的时候会默认加上端口号
  
- 请求资源路径名称（/stu/index.html）
  + 默认的路径或者名称 （xxx.com/stu/ 不指定资源名，服务器会找默认的资源，一般默认资源是default.html/index.html...当然也可以在服务器端自己配置）
  + 注意伪URL地址的处理（URL重写技术是为了增加SEO搜索引擎优化的，动态的网址一般不能被搜索引擎收录，所以我们要把动态网址静态化，此时需要的是重写URL）
  
- 问号传参信息（?from=wx&lx=1）
  + 客户端想把信息传递给服务器，有很多的方式
    + URL地址问号传参
    + 请求报文传输（请求头和请求主题）
  + 也可以不同页面之间的信息交互，例如从列表到详情  
  
- HASH值（#wan）
  + 也能充当信息传输的方式
  + 瞄点定位（不同的hash值展示不同的区域内容）


#### URL编码
> 1.基于encodeURI编码，我们可以基于decodeURI解码，我们一般使用encodeURI编码的是整个URL，这样整个URL中的特殊字符都会自动编码
> 2.encodeURIComponent/decodeURIComponent它相对于encodeURI来说们不用给整个URL编码，而是给URL部分信息进行编码（一般都是问号传参的值编码）

客户端和服务端进行信息传输的时候，如果需要把请求的地址和信息编码，我们则基于以上两种方式处理，服务器端也存在这些方法，这样就可以统一编码了
> 3.客户端还存在一种方式，针对中文编码的方式 escape/unescape,这种方式一般只应用于客户端页面之间自己的处理，例如：从列表跳转到详情页，我们可以把传递的中文值基于这个编码，详情页获取编码后的信息再解码，再比如我们在客户端的cookie信息，如果信息是中文，我们也基于这种办法编码.


#### DNS服务器域名解析
> DNS服务器：域名解析服务器，在服务器上存储着 域名<=>服务器外网IP的相关地址
> 而我们发送请求的时候所谓的DNS解析，其实就是根据域名在DNS服务器上查找到对应服务器的外网IP

**DNS预获取**
- DNS缓存（一般浏览器会在第一次解析后，默认建立缓存，时间很短，只有一分钟左右）
- 减少DNS解析次数（一个网站中我们需要发送请求的域名和服务器尽可能少即可）
- DNS预获取（dns-prefetch）：在页面加载开始的时候，就把当前页面中需要访问其他域名（服务器）的信息进行提前DNS解析，以后加载到具体内容部分可以不用解析了 
- <meta http-equiv="x-dns-prefetch-control" content="off">
- <link rel="dns-prefetch" href="//###" />

#### 和服务器建立TCP连接 三次握手
> 第一次握手：由浏览器发起，告诉服务器我要发送请求了
> 第二次握手：由服务器发起，告诉浏览器我准备接收了，你赶紧发送吧
> 第三次握手：由浏览器发送，告诉服务器，我马上就发了，你准备接收吧

#### HTTP报文
- 请求报文：所有经过传输协议，客户端传递给服务端的内容，都被称为请求报文
  + 起始行
  + 请求头（请求首部）
  + 请求主体
  
- 响应报文：所有经过传输协议，服务器返回给客户端的内容，都被称为响应报文
  + HTTP状态码
  + 响应头
  + 响应主体
- HTTP报文：请求报文+响应报文

#### HTTP状态码
> 1-5开头，三位数字
- 200（ok）：成功
- 201（Created）：一般应用于告诉服务器创建一个新文件，最后服务器创建成功后返回的状态码
- 204 No Conten：对于某些请求（例如：PUT或delete），服务器不想处理，可以返回空内容，并且用204状态码告知
- 301 Moved Permanently:永久重定向（永久转移）
- 302 Mode Temporarily：临时转移（临时重定向）,很早之前基本上使用302做，但是现在基本上使用307来处理事情
- 304 Not Modified：设置HTTP的协商缓存
- 307 ：临时重定向 =>主要用于：服务器的负载均衡
- 400 Bad Request：传递给服务器的参数错误
- 401 Unauthorized：无权限访问
- 404 Not Found：请求地址错误
- 500 Internal Server Error：未知服务器错误
- 503 Service Unavailable：服务器超负荷

遇到link/img/audio/video等是异步去加载资源信息（浏览器分配一个新的线程去加载，主线程继续向下渲染页面）,如果遇到的是script或者@import，则让主线程去加载资源信息（同步），加载完成信息后，再去继续渲染页面

#### DOM的重绘和回流
- 重绘：元素样式的改变（但宽高、大小、位置不变）
- 回流：元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染
- 注意：回流一定会触发重绘，重绘不一定会回流

- 优化：
  + `1.DOM操作的读写分离` 现代版浏览器都有”渲染队列“机制：发现某一行要修改元素样式，不立即渲染，而是看看下一行样式，如果下一行也会改变样式，则把修改样式的操作放到渲染队列中，一直到不再是修改样式的操作后，整体渲染一次，引发一次回流。  （修改样式的时候，下一行如果是获取盒子模型属性，会刷新渲染队列，会增加回流的次数）
  + `2.批量设置样式` div.style.cssText = "width:100px;height:100px"   div.className="box"
  + `3.元素批量修改` 创建文档碎片：document.createDocumentFragement();
  + `4.CSS3硬件加速（GPU加速）` 比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘；transform、opacity、filters...这些属性会触发硬件加速，不会引发回流和重绘。 但是使用过多会占用大量内存，性能消耗严重，有时候会导致字体模糊。

#### 断开TCP连接（四次挥手）
> 第一次挥手：由浏览器发起，发送给服务器，我请求报文已经发送完毕，你准备关闭吧；
> 第二次挥手：由服务器发起，发送给浏览器，我接收完请求报文，我准备关闭，你也准备吧；
> 第三次挥手：由服务器发起，发送给浏览器，我响应报文已经发送完毕，你准备关闭吧；
> 第四次挥手：由浏览器发起，发送给服务器，我响应报文已经接收了，我准备关闭，你也准备吧；

`Connection: keep-alive` 保持TCP不中断，下次请求不需要再次建立连接了（不用再三次握手了）


#### 前端性能优化总结
> `1.减少HTTP请求次数和传输报文大小`
- CSS SPRICE（雪碧图、图片精灵）技术
- 使用字体图标（ICON FONT）或者SVG等矢量图
  + 减少HTTP请求次数或者减少请求内容的大小
  + 渲染更快：因为他们是基于代码渲染的，而对于位图是需要先把图片编码再渲染
  + 不容易失真变形
  + 也可以使用webp格式图片，这种格式要小一些（但是服务器端要支持这种格式的请求处理）
- 图片懒加载（延迟加载）技术
  + 第一次加载页面的时候不去请求真实的图片，提高第一次渲染的速度
  + 当页面加载完，把出现在用户视野区域中的图片做真实加载，没有出现在视野的不加载（节约流量，也能减少对服务器的请求压力）
  + 对于数据我们也尽可能分批加载（不要一次请求过多的数据，例如分页技术）
- 音视频文件取消预加载（preload='none'）,这样可以增加第一次渲染页面的速度，当需要的时候再加载
- 客户端和服务器的数据传输尽可能基于JSON格式完成，XML格式比JSON格式要大一些
- 把页面中的CSS/JS等文件进行合并压缩
  + 合并：争取CSS和JS都只导入一个（webpack可以实现自动合并压缩）
  + 压缩：基于webpack可以压缩、对于图片自己找工具先压缩，还可以使用服务器的GZIP压缩
- 图片地图：对于多次调取使用的图片（尤其是背景图），我们尽可能把它提取为公共的样式类，而不是每一次重新设置background；
- 图片BASE64（用BASE64码代表图片减少HTTP请求，增加浏览器渲染的速度，真实项目中，如果图片加载缓慢，尤其是移动端可能BASE64一下就好了，但是BASE64会导致文件中的代码很难维护，所以少使用；webpack中可以配置图片的BASE64）

> `2.设置各种缓存、预处理和长连接机制`
- 把不经常更改的静态资源做缓存处理（一般做的是304或者ETAG等协商缓存）
- 建立Cache-Control 和Expires HTTP的强缓存
- DNS缓存或者预处理（DNS PREFETCH），减少DNS查找
- 设置本地的离线存储（manifest）或者把一些不经常更改的数据做本地存储（webstorage、indexdb）
- 有钱就做CDN（地域分布式服务器），还有一个方式是加服务器
- 建立Conection：keep-alive  TCP链接
- 使用HTTP2版本协议（现在用的一般都是HTTP1.1）
  + 可以多条TCP通道共存 =>管道化链接

> `3.代码方面的性能优化 ` 
- 减少对闭包的使用（因为过多使用闭包会产生很多步不销毁的内存，处理不好的话，会导致内存溢出”栈溢出“），减少闭包的嵌套（减少作用域链的查找层级）
- 对于动画来说：能用CSS解决的不用JS（能够使用transform处理的，不用传统CSS样式，因为transform开启硬件加速，不会引发回流，使用定位的元素也会好很多，因为定位元素脱离文档流，不会对其它元素的位置造成影响），能用requestAnimationFrame解决的不用定时器。
- 避免使用iframe（因为iframe会嵌入其它页面，这样父页面渲染的时候，还会把子页面也渲染了，渲染进度会变慢）
- 减少直接对DOM的操作（原因是减少DOM的回流和重绘），当代项目都是基于MVVM、MVC数据驱动视图渲染的，对DOM的操作由框架本身完成，性能要好很多
- 代码的低耦合高内聚（基于封装的方式:方法封装、插件封装、组件封装、类库，减少页面中的冗余代码，提高代码使用率）
- 尽可能使用事件委托
- 避免出现死循环或者嵌套循环（嵌套循环会成倍增加循环的次数）
- 项目中尽可能使用异步编程来模拟出多线程的效果，避免主线程阻塞（异步操作基于Promise设计模式来管理）
- JS种不要使用with
- 尽可能减少table布局、避免使用CSS表达式
- 函数的防抖和节流
- 减少使用eval（主要原因是防止压缩代码的时候，由于符号书写不规范，导致代码混乱）
- 减少filter滤镜的使用
- 尽可能减少选择器的层级（选择器是从向右左解析）.box a{} 和 a{}
- 手动回收堆栈内存（赋值为null）
